#pragma once

#include "Memory.hpp"

// std
#include <array>
#include <chrono>
#include <cstdint>

// libraries
#include "nlohmann/json.hpp"

namespace dai
{
namespace bootloader
{


// Config
struct NetworkConfig {
    /**
     * If timeout < 0 - waits forever
     * if timeout == 0 - no timeout
     * if timeout > 0 - waits timeout milliseconds
     */
    std::chrono::milliseconds timeout{15000};
    // Network configuration options
    // IPv4
    std::uint32_t ipv4 = 0;
    std::uint32_t ipv4Mask = 0;
    std::uint32_t ipv4Gateway = 0;
    std::uint32_t ipv4Dns = 0;
    std::uint32_t ipv4DnsAlt = 0;
    bool staticIpv4 = false;
    // TODO(themarpe) - IPv6
    std::array<uint32_t, 4> ipv6 = {};
    std::uint32_t ipv6Prefix = 0;
    std::array<uint32_t, 4> ipv6Gateway = {};
    std::array<uint32_t, 4> ipv6Dns = {};
    std::array<uint32_t, 4> ipv6DnsAlt = {};
    bool staticIpv6 = false;
    // MAC address - if not flashed, overwrites autogenerated one
    std::array<uint8_t, 6> mac = {};
};
// Serialization/Deserialization - NetworkBootloaderConfig
// Doesn't error if some fields are missing
inline void to_json(nlohmann::json& j, const NetworkConfig& c) {
    // Manually serialize the fields
    nlohmann::to_json(j["timeout"], c.timeout.count());
    nlohmann::to_json(j["ipv4"], c.ipv4);
    nlohmann::to_json(j["ipv4Mask"], c.ipv4Mask);
    nlohmann::to_json(j["ipv4Gateway"], c.ipv4Gateway);
    nlohmann::to_json(j["ipv4Dns"], c.ipv4Dns);
    nlohmann::to_json(j["ipv6"], c.ipv6);
    nlohmann::to_json(j["ipv6Prefix"], c.ipv6Prefix);
    nlohmann::to_json(j["ipv6Gateway"], c.ipv6Gateway);
    nlohmann::to_json(j["ipv6Dns"], c.ipv6Dns);
    nlohmann::to_json(j["ipv6DnsAlt"], c.ipv6DnsAlt);
    nlohmann::to_json(j["staticIpv4"], c.staticIpv4);
    nlohmann::to_json(j["staticIpv6"], c.staticIpv6);
    nlohmann::to_json(j["mac"], c.mac);
}
inline void from_json(const nlohmann::json& j, NetworkConfig& c) {
    // Manually serialize the fields
    if(j.contains("timeout")) c.timeout = std::chrono::milliseconds(j["timeout"].get<int>());
    if(j.contains("ipv4")) j["ipv4"].get_to(c.ipv4);
    if(j.contains("ipv4Mask")) j["ipv4Mask"].get_to(c.ipv4Mask);
    if(j.contains("ipv4Gateway")) j["ipv4Gateway"].get_to(c.ipv4Gateway);
    if(j.contains("ipv4Dns")) j["ipv4Dns"].get_to(c.ipv4Dns);
    if(j.contains("ipv6")) j["ipv6"].get_to(c.ipv6);
    if(j.contains("ipv6Prefix")) j["ipv6Prefix"].get_to(c.ipv6Prefix);
    if(j.contains("ipv6Gateway")) j["ipv6Gateway"].get_to(c.ipv6Gateway);
    if(j.contains("ipv6Dns")) j["ipv6Dns"].get_to(c.ipv6Dns);
    if(j.contains("ipv6DnsAlt")) j["ipv6DnsAlt"].get_to(c.ipv6DnsAlt);
    if(j.contains("staticIpv4")) j["staticIpv4"].get_to(c.staticIpv4);
    if(j.contains("staticIpv6")) j["staticIpv6"].get_to(c.staticIpv6);
    if(j.contains("mac")) j["mac"].get_to(c.mac);
}


// Config
struct UsbConfig {
    /**
     * If timeout < 0 - waits forever
     * if timeout == 0 - no timeout
     * if timeout > 0 - waits timeout milliseconds
     */
    std::chrono::milliseconds timeout{3000};

    /**
     * UNKNOWN = 0, LOW, FULL, HIGH, SUPER, SUPER_PLUS
     */
    int maxUsbSpeed = 3;

    /// VID/PID pair used by bootloader
    uint16_t vid = 0x03E7, pid = 0xF63C;
};
// Serialization/Deserialization - UsbBootloaderConfig
// Doesn't error if some fields are missing
inline void to_json(nlohmann::json& j, const UsbConfig& c) {
    // Manually serialize the fields
    nlohmann::to_json(j["timeout"], c.timeout.count());
    nlohmann::to_json(j["maxUsbSpeed"], c.maxUsbSpeed);
    nlohmann::to_json(j["vid"], c.vid);
    nlohmann::to_json(j["pid"], c.pid);
}
inline void from_json(const nlohmann::json& j, UsbConfig& c) {
    // Manually serialize the fields
    if(j.contains("timeout")) c.timeout = std::chrono::milliseconds(j["timeout"].get<int>());
    if(j.contains("maxUsbSpeed")) j["maxUsbSpeed"].get_to(c.maxUsbSpeed);
    if(j.contains("vid")) j["vid"].get_to(c.vid);
    if(j.contains("pid")) j["pid"].get_to(c.pid);
}

struct Config {
    Memory applicationMemory;
    UsbConfig usb;
    NetworkConfig network;
};


// Serialization/Deserialization - Config
// Doesn't error if some fields are missing
inline void to_json(nlohmann::json& j, const Config& c) {
    // Manually serialize the fields - without modifying any existing fields
    nlohmann::to_json(j["appMem"], c.applicationMemory);
    nlohmann::to_json(j["network"], c.network);
    nlohmann::to_json(j["usb"], c.usb);
}
inline void from_json(const nlohmann::json& j, Config& c) {
    // Manually serialize the fields
    if(j.contains("appMem")) j["appMem"].get_to(c.applicationMemory);
    if(j.contains("network")) j["network"].get_to(c.network);
    if(j.contains("usb")) j["usb"].get_to(c.usb);
}


} // namespace bootloader
} // namespace dai

